***
Tags: #What-is-software-engineering #Why-software-engineering #Software-life-cycle-activities #Object-oriented-software-engineering #Software-engineering-and-computer-science
***
### Review Questions
1. What is software engineering. Why is it needed?
	 Below are five definitions of software engineering including the one given in the textbook, listed chronologically. The similarities and differences are shown in Figure 1.1:
    * **IEEE.** The IEEE Computer Society defines software engineering as: "(1) The application of a systematic, disciplined, quantifiable approach to the development, operation, and maintenance of software; that is, the application of engineering of software. (2) The study of approaches as in (1)" ("IEEE Standard Glossary of Software Engineering Terminology," IEEE std 610.12-1990, 1990.)
    * **Ghezzi.** "Software engineering is the field of computer science that deals with the building of software systems that are so large or so complex that they are built by a team or teams of engineers.". It is the "application of engineering to software." (Carlo, Ghezzi, Mehdi Jazayeri and Dino Mandrioli, "Fundamentals of Software Engineering," 2nd Edition, Prentice Hall, 2003.)
    * **Brugge and Dutoit.** Software engineering is a modelling, problem-solving, knowledge acquisition, and rational-driven activity. (Bernd Brugge and Allen H. Dutoit, "Object-Oriented Software Engineering Using UML, Patterns, and Java," 3rd Edition, Prentice Hall, 2010)
    * **Sommerville.** "Software engineering is an engineering discipline that is concerned with all aspects of software production from early stages of system specification through to maintaining the system after it has gone into use." (Ian Sommerville, "Software Engineering", 9th Edition, Addision-Wesley, 2011.)
    * **Kung.** "Software engineering as a discipline is focused on the research, education, and application of engineering processes and methods to significantly increase software productivity and software quality while reducing software costs and time to market." (David Kung, "Object-Oriented Software Engineering: An Agile Unified Methodology," McGraw-Hill Higher Education, 2013.)
      ![[figure-1.1.png]]
2. What is a software development process?
	Software engineering is crucial as software pervades every sector of society. Companies heavily depend on software to manage and expand their operations. With systems growing in size and complexity, software costs have surged to 90-95% of total system costs, emphasizing the need for efficient development. Embedded systems, once reliant on specialized hardware, now demand skilled engineers to design, code, test and maintain millions of lines of source code. The collaboration effort of a software engineering team becomes indispensable in tackling critical systems and producing high-quality software. The intricate nature of large projects, illustrated by the analogy of blind men perceiving an elephant differently, highlights the importance of establishing a common understanding through modeling techniques. Software engineering provides a unified language and methodology, allowing teams to exchange ideas, coordinate efforts and integrate components seamlessly. In a world where timely system development is imperative, software engineering ensures effective collaboration and communication, preventing the long waits that businesses cannot afford.
3. What is software quality assurance?
	Software quality assurance ensures that the development activities are performed properly and the software artefacts produced by the development activities meet the software requirements and desired quality standards.
4. What is software project management?
	Software project management oversees the control and administrations of the development and software quality assurance activities. Project management activities include effort estimations, project planning and scheduling, risk management and project administrations among others. These activities ensure that the software system is delivered on time and within budget.
5. What is software configuration management?
	Software configuration management. During the development process, numerous software artifacts are produced. These include requirements specification, software design code, test cases, user's manual and the like. These compose the software, or part of it, under different stages of the development process. For example, the requirements sepcification is the software in its non-executable form. The design specification is a refinement of the requirements specifications. The code is a refinement of the desing. These  documents depend on each other. For example, software design depends on the requirements. If the requirements are changed, the desing has to change. This in turn may require change to the code that implements the desing. Therefore, software engineering needs a mechanism to coordinate so that changes are made consistently.
6. What are the differences between object-oriented software engineering and conventional software engineering?
	The main difference between conventional software engineering and OO software engineering is paradigm shift — that is, how they view the world and systems. Because of this, they differ in the basic concepts, basic building blocks and starting point for the conceptualization, design and implementation of software systems. These in turn effect software quality assurance, project management (for example, effort estimation and planning), and software configuration management.
7. What are the differences and relationships between software engineering and computer science? Can we have one without the other?
	Software engineering and computer science are distinct disciplines, with computer science focusing on theoretical aspects like algorithms, data structures and computational efficency, while software engineering applies these concepts to practical solutions. Software engineering emphasizes efficient development methodologies, user interface design and business analysis. Despite differences, the two are closely related, with software engineering being the application of computer science. However, software engineering has its own research areas, including software processes and validation techniques, aiming to enhance the software quality. Both fields are essential and complement each other and it's challenging to have one without the other.

### Exercises
2. Describe in a brief article the functions of software development process, software quality assurance, software project management, and software configuration management. Discuss how these work together during the software development life cycle. Discuss how they improve software PQCT.
	The functions of software development process, software quality assurance software project management and software configuration management are all discussed in the chapter review questions. All of software development process, software quality assurance, project management and software configuration management contribute to PQCT. In particular, good software development practices would apply well-established software development methodologies, software design principles, software design patterns, coding standards, test-driven development. These could lead to improvement of software productivity and software quality while at the same time reduce software costs and time to market. SQA ensures that the software meets the requirements and quality standards. It contributes to improvement of software quality. This in turn reduces rework and field-detected bugs; and hence, it also improves software productivity, reduces costs associated with rework and fixing field-detected bugs. Software project management ensures proper planning and administration of the software project. In particular, it should request the needed resources to develop the software system, properly schedule the development activities and SQA activities, manage budget and risks. These indirectly contribute to improvement of software productivity and software quality. Proper planning and administration of development and SQA activities directly contribute to reducing software development costs and time to market. This is because these activities could be performed smoothly, e.g., the needed components and resources are in place. SCM supports project management, SQA and software development process. It ensures that components of the software system are constructed and modified consistently and cost-effectively. Consistent modification implies productivity and quality, and cost-effectiveness implies reduction in cost and time to market.
3. Should optimization be a focus of software engineering? Briefly explain, and justify your answer with a practical example.
	The answer to this question may depend on the interpretation of “optimization.” If it is about “optimization of software PQCT,” then it is the focus of software engineering. If it is about performance optimization, then it should not be a focus, although SE also considers performance issues such as testing for performance. The database access example discussed in Section 1.5 is a practical example. Optimization could be a focus for a given project. For example, the construction of a compiler for multi-core computers. In this case, it depends on whether the project is classified as a software engineering, or a computer science project. It might be an SE project. For example, it is constructed for a certain application. (See solution to Exercise 1.6 for more on optimization and SE.)
5. There are inter-dependencies between software productivity, quality, cost, and time to market. For example, more time and effort spent in coding could increase productivity. This may result in less time and effort in software quality assurance because the total time and effort are constants. Poor quality could cost productivity due to rework. Identify three pairs of such inter-dependencies of your choice. Discuss their short-term and long-term impacts on the software development organization. How should software engineering solve the "dilemmas" induced by the inter-dependencies?
	Barry Boehm in his papers on software engineering economics pointed out that the cost to fix a requirements error increases exponentially with time. That is, removing errors as early as possible is a cost-saving effort. This also coincides with the philosophy advocated by agile methods — that is, test early and often. Thus, if SQA is carried out as a life-cycle activity and follows a good SQA process, then it should detect requirements, design and implementation errors early. This reduces bug fixing costs exponentially. Moreover, since SQA is a cooperate-wide practice, developers are conscious of developing quality software. This should significantly reduce the error rate; and hence, it reduces the cost that would otherwise have to be spent to fix the bugs. In the short term, implementing and executing an SQA framework may reduce productivity, increase costs and time to market. However, in the long term, quality software brings many benefits to the organization. These include significant reduction in error rate and error correction costs, customer satisfaction, and increase in software capability maturity level. These should positively impact productivity, cost and time to market. One should be aware that quality is not the more the better. To a certain point, there is the so-called “diminishing returns.” Thus, how much SQA is appropriate remains a research problem in general and for a software organization in particular.
6. What are the differences and relationships between 00 software engineering and conventional software engineering? Discuss whether object-oriented software engineering will replace conventional software engineering.
	The main difference between conventional software engineering and OO software engineering is paradigm shift — that is, how they view the world and systems. Because of this, they differ in the basic concepts, basic building blocks, and starting point for the conceptualization, design and implementation of software systems. These in turn affect SQA, project management (for example, effort estimation and planning), and SCM. Will OO replace the conventional paradigm? The answer should be no . The reasons are:
	1. There are numerous systems that were developed using one or more of the conventional paradigms. It is very costly and risky to replace these systems. Therefore, the other paradigms will continue to exist because bug fixing, performance improvements, and functional enhancements to these systems are required.
	2. There are hundreds of thousand organizations and millions of software developers using only the conventional paradigms. It is practically impossible and unjustifiable to require them to convert to the OO paradigm.
	3. A conventional paradigm may be more suitable for some projects. For example, scientific computing typically involves series of transformations of input into output. Therefore, the function-oriented paradigm is more suitable for such applications. Moreover, scientific computing emphasizes computing speed, the ability to solve complex computation problems, and the accuracy of the result. OO programming languages may not satisfy such requirements. These and the facts that scientific computing is there to stay and expand into computational sciences imply that the function-oriented paradigm will continue to exist.
	In addition to the above, one should know that different parts of a system may be developed using different paradigms. For example, a subsystem that performs scientific computing may be developed using the function-oriented paradigm. A database subsystem may be developed using the data-oriented paradigm. In practice, there are systems that are modeled and designed using the OO paradigm but implemented in a non-OO language. Similarly, there are projects that are modeled and designed using a conventional paradigm but implemented in SmallTalk or C++.